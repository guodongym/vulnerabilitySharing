package com.starsec.dao;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.transform.Transformers;
import org.springframework.stereotype.Repository;

import com.starsec.model.DataTablePage;
import com.starsec.po.LeakType;
import com.starsec.vo.LeakTypeVo;
import com.starsec.vo.SysDepartmentVo;

/** 漏洞类型(LEAK_TYPE) **/
@Repository
public class LeakTypeDao extends BaseDao<LeakType, Serializable> {

	public List<LeakType> findAll() {
		String hql = " from " + LeakType.class.getCanonicalName();
		return super.getListByHQL(hql);
	}


	/**
	 * 保存或修改漏洞类型
	 * 
	 * @param leakTypeForSaveOrUpdate
	 * @return
	 */
	public Integer saveOrUpdateSysUserGroup(LeakType leakTypeForSaveOrUpdate) {
		try {
			super.saveOrUpdate(leakTypeForSaveOrUpdate);
			return 1;
		} catch (HibernateException e) {
			return 0;
		}
	}

	/**
	 * 分页查询漏洞类型
	 * 
	 * @param pageParameBean
	 * @return
	 */
	public DataTablePage findPageLeakType(DataTablePage page) {
		//判断是否要搜索
		Boolean isSearch =StringUtils.isNotBlank(page.getSearch());
		String sqlString = " SELECT   " 
				+ " DISTINCT  " 
				+ " leak_type.leak_type_id as id,   " 
				+ " leak_type.leak_name as leakName ,   " 
				+ " leak_type.parent_id  as parentId,   " 
				+ " CASE WHEN parentLeakType.leak_name is null  "
				+ " THEN '-'   "
				+ " ELSE parentLeakType.leak_name END AS parentLeakName " 
				+ " from    " 
				+ " leak_type   " 
				+ " LEFT JOIN leak_type as parentLeakType   " 
				+ " ON leak_type.parent_id = parentLeakType.leak_type_id   " 
				+ " WHERE 1=1   " ;
		if(isSearch){
			sqlString=sqlString+
					" and ( " 
					+ " leak_type.leak_name like :leakName   "
					+ " OR parentLeakType.leak_name like :parentLeakName   "
					+ "	) ";
		}
		sqlString = sqlString+
				 " order by leak_type.leak_type_id DESC  "
				;
		
		DataTablePage retValue = new DataTablePage();

		Query query = super.getSession().createSQLQuery(sqlString);
		//如果 有搜索词
		if(isSearch){
			query.setParameter("leakName", "%"+page.getSearch()+"%");
			query.setParameter("parentLeakName","%"+ page.getSearch()+"%");
		}
		query.setResultTransformer(Transformers.aliasToBean(LeakTypeVo.class));
		Integer pageNo = page.getPageNo();
		Integer pageSize = page.getLimit();
		int currentPage = pageNo > 1 ? pageNo : 1;

		String hql = "select count(*) from ( " + sqlString + " ) as countTable ";
		Query queryForCount = super.getSession().createSQLQuery(hql);
		//如果 有搜索词
		if(isSearch){
			queryForCount.setParameter("leakName", "%"+page.getSearch()+"%");
			queryForCount.setParameter("parentLeakName","%"+ page.getSearch()+"%");
		}
		Long count = Long.parseLong(queryForCount.uniqueResult().toString());
		retValue.setTotal(count.intValue());

		@SuppressWarnings("unchecked")
		List<SysDepartmentVo> itemList = query.setFirstResult((currentPage - 1) * pageSize).setMaxResults(pageSize).list();
		if (itemList == null) {
			itemList = new ArrayList<SysDepartmentVo>();
		}
		retValue.setRows(itemList);
		return retValue;

	}

	/**
	 * 查询 子漏洞类型总数
	 * 
	 * @param id
	 * @return
	 */
	public Long findCountChild(Integer id) {
		String countHql = " select count(*) from " + LeakType.class.getCanonicalName() + "  as leakType where leakType.parentId = ?";
		Long count = super.countByHql(countHql, id);
		return count;
	}

	/**
	 * 删除漏洞类型
	 * 
	 * @param leakTypeForDelete
	 * @return
	 */
	public boolean deleteLeakType(LeakType leakTypeForDelete) {
		try {
			super.delete(leakTypeForDelete);
			return true;
		} catch (HibernateException e) {

			return false;
		}
	}

	/**
	 * 批量删除漏洞类型
	 * 
	 * @param leakTypeList
	 * @return
	 */
	public boolean deleteLeakTypeList(List<LeakType> leakTypeList) {
		try {
			for (LeakType leakType : leakTypeList) {
				super.delete(leakType);
			}
			return true;
		} catch (HibernateException e) {
			return false;
		}
	}


	public Set<LeakType> findByIds(Integer[] leakTypeIds) {
		Set<LeakType> set = null;
		if (leakTypeIds != null) {
			set = new HashSet<LeakType>();
			for (Integer leakTypeId : leakTypeIds) {
				LeakType leakType = get(leakTypeId);
				set.add(leakType);
			}
		}
		return set == null || set.size() == 0 ? null : set;
	}

	public Set<LeakType> findByIds(String leakTypeIds) {
		Set<LeakType> set = null;
		if (StringUtils.isNotBlank(leakTypeIds)) {
			set = new HashSet<LeakType>();
			String[] typeIds = leakTypeIds.split(",");
			for (String leakTypeId : typeIds) {
				LeakType leakType = get(Integer.valueOf(leakTypeId));
				set.add(leakType);
			}
		}
		return set == null || set.size() == 0 ? null : set;
	}


	/**
	 *根据漏洞类型名称查出漏洞数量
	 * @param leakTypeName 
	 * @return
	 */
	public Long findCountByName(String leakTypeName) {
		String countHql = " select count(*) from "+ LeakType.class.getCanonicalName() 
				+"  where leakName = ?";
		Long count = super.countByHql(countHql,leakTypeName);
		return count;
	}

	/**
	 * 根据name查询漏洞类型总数
	 * @param leakName
	 * @return
	 */
	public Long findByName(String leakName) {
		String countHql = " select count(*) from "+ LeakType.class.getCanonicalName() 
				+"   where  leakName = ?";
		Long count = super.countByHql(countHql,leakName);
		return count;
	}
}