package com.starsec.service;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.starsec.constants.LeakStatus;
import com.starsec.constants.RiskLevel;
import com.starsec.constants.SysRoleType;
import com.starsec.dao.LeakDao;
import com.starsec.dao.LeakTypeDao;
import com.starsec.dao.SysAttachmentDao;
import com.starsec.dao.SysLogDao;
import com.starsec.dao.SysUserDao;
import com.starsec.model.DataTablePage;
import com.starsec.model.Result;
import com.starsec.po.Leak;
import com.starsec.po.LeakType;
import com.starsec.po.SysAttachment;
import com.starsec.po.SysRole;
import com.starsec.po.SysUser;
import com.starsec.util.DateUtil;
import com.starsec.util.GenerateComponent;
import com.starsec.util.SessionUtil;
import com.starsec.vo.AnnualLeakStatistic;
import com.starsec.vo.AuditResultStatistic;
import com.starsec.vo.LeakAmountInLeakType;
import com.starsec.vo.LeakSupplementBean;
import com.starsec.vo.LeakVo;
import com.starsec.vo.PageParameBean;

/**
 * 漏洞
 * 
 * @author cheng cheng
 *
 */
@Service
public class LeakService {

	// 用户组
	@Autowired
	private LeakDao leakDao;
	// 漏洞类型
	@Autowired
	private LeakTypeDao leakTypeDao;

	// 用户信息
	@Autowired
	private SysUserDao sysUserDao;
	
	// 附件地址
	@Autowired
	private SysAttachmentDao sysAttachmentDao;
	
	
	@Autowired
	private GenerateComponent generateComponent;
	

	//日志
	@Autowired
	private SysLogDao sysLogDao;
	//日志模块
	private static final String logTarget = "漏洞";

	

	/**
	 * 分页查询漏洞
	 * @param reviewEndTime 
	 * @param reviewStartTime 
	 * @param createEndTime 
	 * @param createStarTime 
	 * @param reviewStatus 
	 * @param leakStatus 
	 * @param leakRiskLevel 
	 * @param leakTypeId 
	 * @param likeKeyWord 
	 * 
	 * @param pageParameBean
	 * @return
	 */
	public DataTablePage findPageLeaks(DataTablePage dataTablePage, String likeKeyWord,
			Integer leakTypeId, Integer leakRiskLevel, Integer leakStatus,
			Integer reviewStatus, String createStarTime, String createEndTime, 
			String reviewStartTime, String reviewEndTime) {
		// 设置页面编号
		dataTablePage.resetPageNo();
		return leakDao.findPageLeak( dataTablePage,
				 likeKeyWord, leakTypeId, leakRiskLevel,
				 leakStatus, reviewStatus, createStarTime,
				 createEndTime, reviewStartTime, reviewEndTime);
	}

	
	/**
	 * 判断是否相同漏洞名称
	 * @param leak
	 * @return
	 */
	private Boolean isExistSameName(Leak leak) {
		Long countLeak = leakDao.findLeakByName(leak.getLeakName());
		if(countLeak>0){
			return true;
		}
		return false;
	}
	/**
	 * 用漏洞id获得漏洞类型
	 * 
	 * @param leakSupplementBean
	 * @return
	 */
	private LeakType getLeakType(LeakSupplementBean leakSupplementBean) {
		LeakType leakType = leakTypeDao.get(leakSupplementBean.getLeakTypeId());
		return leakType;
	}

	/**
	 * 删除漏洞
	 * 
	 * @param id
	 * @return
	 */
	public Result deleteLeak(Integer id) {
		//判断漏洞是否有删除权限
		if(!deleteLeakRight(id)){
			return Result.error("没有删除权限");
		}
		Leak leakForDelete = leakDao.findLeakById(id);
		leakForDelete.setLeakStatus(LeakStatus.已删除.value());
		leakDao.update(leakForDelete);
		deleteLeakLog(leakForDelete);//删除日志
		return Result.SUCCESS;
	}

	/**
	 * 判断漏洞是否有删除权限
	 * @param id
	 * @return
	 */
	private boolean deleteLeakRight(Integer id) {
		Integer leakStatus = leakDao.findLeakById(id).getLeakStatus();
		if(isSysUser()
				&&(LeakStatus.未审核.value().equals(leakStatus)||LeakStatus.已审核.value().equals(leakStatus))
				){
			return true;
		}
		return false;
	}

	/**
	 * 判断是否是管理员
	 * @return
	 */
	private boolean isSysUser() {
		boolean flag = false;
		Set<SysRole> sysRoles = SessionUtil.loginUser().getSysRoles();
		for (SysRole sysRole : sysRoles) {
			if(SysRoleType.系统管理员.value() == sysRole.getId()){
				flag = true;
				break;
			}
		}
		return flag;
	}

	/**
	 * 删除漏洞   日志
	 * @param leakForDelete 
	 * @return
	 */
	private void deleteLeakLog(Leak leakForDelete) {
		String logContent = "删除漏洞   "+getPartLogContent(leakForDelete);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	/**
	 * 批量删除漏洞
	 * 
	 * @param idListString
	 * @return
	 */
	public Result deleteLeakList(String idListString) {
		List<Integer> idList = parseStringToIntegerList(idListString);
		for (Integer id : idList) {
			// 根据id查到漏洞
			Leak leakForDelete = leakDao.findLeakById(id);
			leakForDelete.setLeakStatus(LeakStatus.已删除.value());
			leakDao.update(leakForDelete);
			deleteLeakLog( leakForDelete) ;//删除日志
		}
		return Result.SUCCESS;
	}

	/**
	 * string转成数组
	 * 
	 * @param str
	 * @return
	 */
	public List<Integer> parseStringToIntegerList(String str) {
		str = str.replace("[", "");
		str = str.replace("]", "");
		String[] ss = str.split(",");
		List<Integer> integerList = new ArrayList<Integer>();
		for (int i = 0; i < ss.length; i++) {
			Integer integer = Integer.parseInt(ss[i]);

			integerList.add(integer);
		}
		return integerList;

	}

//	/**
//	 * 分页查询漏洞和评论数 LeakAndCountComments
//	 * 
//	 * @param pageParameBean
//	 * @return
//	 */
//	public DataTablePage findPageLeakAndCountComments(PageParameBean pageParameBean) {
//		// 设置页面编号
//		pageParameBean.resetPageNo();
//		DataTablePage pageLeakAndCountComments = leakDao.findPageLeakAndCountComments(pageParameBean);
//		return pageLeakAndCountComments;
//	}

	/**
	 * 根据漏洞id获得漏洞信息
	 * 
	 * @param id
	 * @return
	 */

	public Leak findLeakById(Integer id) {
		Leak Leak = leakDao.findLeakById(id);
		return Leak;
	}


	/**
	 * 漏洞状态统计,查出提交和提交的漏洞总数
	 * 
	 * @return
	 */
	public Map<String, Object> countLeakStatus() {
		Map<String, Object> hashMap = new HashMap<String, Object>();
		// 获得未发布的漏洞数量
		Long countLeakUnreleased = leakDao.findCountLeakUnreleased();
		hashMap.put("countLeakUnreleased", countLeakUnreleased);

		// 获得已发布的漏洞数量
		Long countLeakReleased = leakDao.findCountLeakReleased();
		hashMap.put("countLeakReleased", countLeakReleased);

		return hashMap;
	}

	/**
	 * 漏洞类型统计
	 * 
	 * @return
	 */
	public List<LeakAmountInLeakType> countLeakTypes() {
		// 漏洞类型统计
		List<LeakAmountInLeakType> leakAmountInLeakTypeList = leakDao.countLeakTypes();
		return leakAmountInLeakTypeList;
	}

	/**
	 * 审核结果统计 统计每个审核结果的漏洞个数
	 * 
	 * @return
	 */
	public List<AuditResultStatistic> findAuditResultStatistics() {

		List<AuditResultStatistic> auditResultStatisticList = leakDao.findAuditResultStatistics();
		return auditResultStatisticList;
	}

	/**
	 * 漏洞 个人榜
	 * 
	 * @return
	 */
	public DataTablePage findPageSysUserRanks(DataTablePage page) {
		// 设置页面编号
		page.resetPageNo();
		DataTablePage pageSysUserRanks = leakDao.findPageSysUserRanks(page);
		return pageSysUserRanks;
	}

	/**
	 * 漏洞 单位榜
	 * 
	 * @param page
	 * @return
	 */
	public DataTablePage findPageDepartmentRanks(DataTablePage page) {
		// 设置页面编号
		page.resetPageNo();
		DataTablePage pageDepartmentRanks = leakDao.findPageDepartmentRanks(page);
		return pageDepartmentRanks;
	}

	/**
	 * 年度漏洞统计
	 * 
	 * @return
	 */
	public List<AnnualLeakStatistic> findAnnualLeakStatistis() {
		List<AnnualLeakStatistic> annualLeakStatistis = leakDao.findAnnualLeakStatistis();
		return annualLeakStatistis;
	}

	/**
	 * 已发布漏洞信息
	 * 
	 * @param pageParameBean
	 * @param userId
	 * @return
	 */
	public DataTablePage findPageUnreleasedLeaks(PageParameBean pageParameBean, Integer userId) {
		// 设置页面编号
		pageParameBean.resetPageNo();
		DataTablePage pageLeak = leakDao.findPageUnreleasedLeaks(pageParameBean, userId);
		return pageLeak;
	}

	/**
	 * 已发布漏洞信息
	 * 
	 * @param pageParameBean
	 * @return
	 */
	public DataTablePage findPageReleasedLeaks(PageParameBean pageParameBean, Integer userId) {
		pageParameBean.resetPageNo();
		DataTablePage pageLeaks = leakDao.findPageReleasedLeaks(pageParameBean, userId);
		return pageLeaks;
	}

	/**
	 * 保存漏洞
	 * @param leak
	 * @param leakSupplementBean
	 * @param session 
	 * @return
	 */
	public Result saveLeak(Leak leak, LeakSupplementBean leakSupplementBean) {
		//判断是否相同漏洞名称
		if(isExistSameName(leak)){
			return Result.error("有相同漏洞名");
		}
		leak.setSubmitUser(SessionUtil.loginUser());//提交人
		leak.setLeakStatus(LeakStatus.未发布.value());//是否发布
		leak.setSysAttachment(getSysAttachment(leakSupplementBean));//获得附件信息
		leak.setSubmitTime(new Date());//提交日期
		leak.setLeakNo(generateComponent.GenerateLeakNo());//漏洞编号
		leak.setLeakType(getLeakType( leakSupplementBean));
		
		// 添加漏洞
		Integer id = (Integer)leakDao.save(leak);
		saveLeakLog(id);
		return Result.SUCCESS;
	}
	
	
	/**
	 * 添加漏洞   日志
	 * @param leakForDelete 
	 * @return
	 */
	private void saveLeakLog( Integer id) {
		Leak leak  =leakDao.findLeakById(id);
		String logContent = "添加漏洞  " +getPartLogContent(leak);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}
	/**
	 *  漏洞日志的一部分
	 * @param leak
	 * @return
	 */
	private String getPartLogContent( Leak leak) {
		StringBuffer partLogContent = new StringBuffer();
		partLogContent.append(" id:");
		partLogContent.append(leak.getId());
		partLogContent.append("   漏洞名称:");
		partLogContent.append(leak.getLeakName());
		return partLogContent.toString();
	}
	
	/**
	 * 修改漏洞
	 * @param leak
	 * @param leakSupplementBean
	 * @param session 
	 * @return
	 */
	public Result updateLeak(Leak leak, LeakSupplementBean leakSupplementBean) {
		//判断是否有修改权限
		boolean  canUpdate = getCanUpdate(leak.getId());
		if(!canUpdate){
			return Result.error("没有更新权限");
		}
		
		
		//判断是否相同漏洞名称
		if(!isQuondamName(leak)&&isExistSameName(leak)){
			return Result.error("有相同漏洞名");
		}
		//获得要更新的漏洞信息
		Leak leakForUpdate = getLeakForUpdate( leak,  leakSupplementBean);
		// 修改漏洞
		leakDao.update(leakForUpdate);
		updateLeakLog(leakForUpdate);//修改漏洞 日志
		return Result.SUCCESS;
	}

	/**
	 * 修改漏洞 日志
	 * @param leakForUpdate
	 */
	private void updateLeakLog(Leak leakForUpdate) {
		String logContent = "修改漏洞  " +getPartLogContent(leakForUpdate);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	/**
	 * 获得要更新的漏洞信息
	 * @param leak
	 * @param leakSupplementBean
	 * @return
	 */
	private Leak getLeakForUpdate(Leak leak, LeakSupplementBean leakSupplementBean) {
		Leak leakForUpdate = leakDao.findLeakById(leak.getId());
		leakForUpdate.setLeakStatus(LeakStatus.未发布.value());//是否发布
		if(null!=leakSupplementBean.getSysAttachmentId()){
			leakForUpdate.setSysAttachment(getSysAttachment(leakSupplementBean));//获得附件信息
		}
		leakForUpdate.setLeakType(getLeakType( leakSupplementBean));//漏洞
		
		leakForUpdate.setCnnvdId(leak.getCnnvdId());
		leakForUpdate.setCnvdId(leak.getCnvdId());
		leakForUpdate.setCveId(leak.getCveId());
		leakForUpdate.setInfluenceSystemName(leak.getInfluenceSystemName());
		leakForUpdate.setLeakAuthor(leak.getLeakAuthor());
		leakForUpdate.setLeakDetail(leak.getLeakDetail());
		leakForUpdate.setLeakName(leak.getLeakName());
		leakForUpdate.setLeakOutline(leak.getLeakOutline());
		leakForUpdate.setRiskLevel(leak.getRiskLevel());
		return leakForUpdate;
	}


	/**
	 * 是否为原来的名字 
	 * @param leak
	 * @return
	 */
	private boolean isQuondamName(Leak leak) {
		Leak leakFinded  = leakDao.get(leak.getId());
		if(leak.getLeakName().equals(leakFinded.getLeakName())){
			return true;
		}
		return false;
	}
	/**
	 * 获得附件信息
	 * @param leakSupplementBean
	 * @return
	 */
	private SysAttachment getSysAttachment(LeakSupplementBean leakSupplementBean) {
		Integer sysAttachmentId = leakSupplementBean.getSysAttachmentId();
		if(null!=sysAttachmentId){
			return sysAttachmentDao.get(sysAttachmentId);
		}
		return null;
	}

	/**
	 * 保存并发布漏洞
	 * 
	 * @param leak
	 * @param leakSupplementBean
	 * @param session 
	 * @return
	 */
	public Result saveAndReleaseLeak(Leak leak, LeakSupplementBean leakSupplementBean) {
		//判断是否相同漏洞名称
		if(isExistSameName(leak)){
			return Result.error("有相同漏洞名");
		}
		leak.setSubmitUser(SessionUtil.loginUser());//提交人
		leak.setLeakStatus(LeakStatus.未审核.value());//是否发布
		leak.setSysAttachment(getSysAttachment(leakSupplementBean));//获得附件信息
		leak.setSubmitTime(new Date());//提交日期
		leak.setLeakNo(generateComponent.GenerateLeakNo());//漏洞编号
		leak.setLeakType(getLeakType( leakSupplementBean));
		
		// 添加漏洞
		leakDao.save(leak);
		saveAndReleaseLeakLog(leak);//保存并发布漏洞 日志
		return Result.SUCCESS;
	}
	
	/**
	 * 保存并发布漏洞 日志
	 * @param leak 
	 */
	private void saveAndReleaseLeakLog(Leak leak) {
		String logContent = "保存并发布漏洞 " +getPartLogContent(leak);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	/**
	 * 修改并发布漏洞
	 * @param leak
	 * @param leakSupplementBean
	 * @param session 
	 * @return
	 */
	public Result updateAndReleaseLeak(Leak leak, LeakSupplementBean leakSupplementBean) {
		
		//不是原来的名字,没有相同的名字
		if(!isQuondamName(leak)&&isExistSameName(leak)){
			return Result.error("有相同漏洞名");
		}
		//获得用于更新的漏洞信息
		Leak leakForUpdate  = getLeakForUpdateAndRelease(leak,leakSupplementBean); 

		// 修改漏洞
		leakDao.update(leakForUpdate);
		updateAndReleaseLeakLog(leakForUpdate);
		return Result.SUCCESS;
	}

	
	/**
	 * 修改并发布漏洞    日志
	 * @param leak 
	 */
	private void updateAndReleaseLeakLog(Leak leak) {
		String logContent = "修改并发布漏洞 " +getPartLogContent(leak);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}

	/**
	 * 获得用于更新并发布的漏洞信息
	 * @param leak
	 * @param leakSupplementBean 
	 * @return
	 */
	private Leak getLeakForUpdateAndRelease(Leak leak, LeakSupplementBean leakSupplementBean) {
		Leak leakForUpdateAndRelease = leakDao.findLeakById(leak.getId());
		//如果是没有提交
		if(LeakStatus.未发布.value().equals(leakForUpdateAndRelease.getLeakStatus())){
			//更新提交日期
			leakForUpdateAndRelease.setSubmitTime(new Date());//提交日期
		}
		//如果是提交人修改,
		if(SessionUtil.loginUser().getId() ==leakForUpdateAndRelease.getSubmitUser().getId() ){
			leakForUpdateAndRelease.setLeakStatus(LeakStatus.未审核.value());//是否发布
		}
		

		if(null!=leakSupplementBean.getSysAttachmentId()){
			leakForUpdateAndRelease.setSysAttachment(getSysAttachment(leakSupplementBean));//获得附件信息
		}
		leakForUpdateAndRelease.setLeakType(getLeakType( leakSupplementBean));
		
		leakForUpdateAndRelease.setCnnvdId(leak.getCnnvdId());
		leakForUpdateAndRelease.setCnvdId(leak.getCnvdId());
		leakForUpdateAndRelease.setCveId(leak.getCveId());
		leakForUpdateAndRelease.setInfluenceSystemName(leak.getInfluenceSystemName());
		leakForUpdateAndRelease.setLeakAuthor(leak.getLeakAuthor());
		leakForUpdateAndRelease.setLeakDetail(leak.getLeakDetail());
		leakForUpdateAndRelease.setLeakName(leak.getLeakName());
		leakForUpdateAndRelease.setLeakOutline(leak.getLeakOutline());
		leakForUpdateAndRelease.setRiskLevel(leak.getRiskLevel());
		return leakForUpdateAndRelease;
	}


	/**
	 * @Title: findLatestReleaseLeak 
	 * @Description: 首页，获取最新发布漏洞
	 * @author zhaogd 
	 * @param pageSize 需要的漏洞条数
	 * @return
	 */
	public List<LeakVo> findLatestReleaseLeak(Integer pageSize,Integer userID) {
		return leakDao.findLatestReleaseLeak(pageSize ,userID);
	}

	
	public List<LeakVo> findLatestAuditLeak(Integer pageSize) {
		return leakDao.findLatestAuditLeak(pageSize);
	}

	
	/**
	 * 获得页面加载所需信息:漏洞类型,危险等级
	 * @return
	 */
	public Map<String, Object> getLoadingInfo() {
		Map<String, Object> loadInfo = new HashMap<String, Object>();
		//获得漏洞类型
		List<LeakType> leakTypes = leakTypeDao.findAll();
		loadInfo.put("leakTypes", leakTypes);
		//获得危险等级
		List<Map<String, Object>> riskLevels = getRiskLevels();
		loadInfo.put("riskLevels", riskLevels);
		
		return loadInfo;
	}

	


	/**
	 * 获得危险等级
	 * @return
	 */
	private List<Map<String, Object>> getRiskLevels() {
		List<Map<String, Object>> riskLevels = new  ArrayList<Map<String, Object>>();
		
		//高
		Map<String, Object> riskLevel1 = new HashMap<String, Object>();
		riskLevel1.put("riskLevel", RiskLevel.高.value());
		riskLevel1.put("levelName", RiskLevel.高.toString());
		riskLevels.add(riskLevel1);
		//中
		Map<String, Object> riskLevel2 = new HashMap<String, Object>();
		riskLevel2.put("riskLevel", RiskLevel.中.value());
		riskLevel2.put("levelName", RiskLevel.中.toString());
		riskLevels.add(riskLevel2);
		
		//低
		Map<String, Object> riskLevel3 = new HashMap<String, Object>();
		riskLevel3.put("riskLevel", RiskLevel.低.value());
		riskLevel3.put("levelName", RiskLevel.低.toString());
		riskLevels.add(riskLevel3);
		
		return riskLevels;
	}

	/**
	 * 我的未发布漏洞
	 * @param session
	 * @param dataTablePage 
	 * @return
	 */
	public DataTablePage findMyUnreleasePageLeaks(HttpSession session, DataTablePage dataTablePage) {
		dataTablePage.resetPageNo();
//		SysUser loginUser = (SysUser)session.getAttribute(Constants.LOGIN_USER);
		SysUser loginUser = SessionUtil.loginUser();
		return leakDao.findMyUnreleasePageLeaks(loginUser.getId() ,dataTablePage);
	}

	/**
	 * 我的已发布漏洞
	 * @param session
	 * @param dataTablePage
	 * @return
	 */
	public DataTablePage findMyReleasePageLeaks(DataTablePage dataTablePage) {
		dataTablePage.resetPageNo();
		return leakDao.findMyReleasePageLeaks(SessionUtil.loginUser().getId() ,dataTablePage);
	}

	/**
	 * 发布漏洞信息
	 * @param leakId
	 * @return
	 */
	public Result releaseLeak(Integer leakId) {
		//判断是否有发布权限 
		boolean releaseRight = getReleaseRight(leakId);
		if(!releaseRight){
			return Result.error("没有发布权限 ");
		}
		//根据id获得漏洞信息
		Leak leak = leakDao.findLeakById(leakId);
		leak.setLeakStatus(LeakStatus.未审核.value());
		leak.setSubmitTime(DateUtil.currentTime());
		Boolean isSuccess = leakDao.saveOrUpdateLeak(leak);
		if(!isSuccess){
			return Result.error("保存不成功");
		}
		releaseLeakLog(leak);//发布漏洞信息  日志
		return Result.SUCCESS;
	}

	/**
	 * 判断是否有发布权限 
	 * @param leakId
	 * @return
	 */
	private boolean getReleaseRight(Integer leakId) {
		Leak po = leakDao.findLeakById(leakId);
		//是自己的漏洞   漏洞审核前           
		if(isSubmitUser(po)&&isBeforAudit(po)){
			return true;
		}
		return false;
	}


	/**
	 * 发布漏洞信息  日志
	 * @param leak
	 */
	private void releaseLeakLog(Leak leak) {
		String logContent = "发布漏洞信息  " +getPartLogContent(leak);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	/**
	 * 我的审核信息
	 * @param page 
	 * @return
	 */
	public DataTablePage pageMyReviewLeaks(DataTablePage dataTablePage) {
		dataTablePage.resetPageNo();
		//从session中获得登陆的用户信息
		SysUser loginUser = SessionUtil.loginUser();
		loginUser = sysUserDao.findSysUserById(loginUser.getId());
		Set<SysRole> sysRoles =  loginUser.getSysRoles();
		//如果有漏洞审核的权限,返回已发布漏洞信息
		for (SysRole sysRole : sysRoles) {
			if(sysRole.getId()==SysRoleType.漏洞审计员.value()){
				return leakDao.findPageReleasedLeak(dataTablePage);
			}
		}
		return null;
	}

	/**
	 *根据id获得用户信息vo
	 * @param leakId
	 * @return
	 */
	public LeakVo findVoById(Integer leakId) {
		Leak Leak = leakDao.get(leakId);
		LeakVo leakVo = new LeakVo();
		leakVo.from(Leak);
		return leakVo;
	}


	/**
	 * 提交审核
	 * @param leak
	 * @return
	 */
	public Result submitAudit(Leak leak) {
		Leak leakForSave = leakDao.findLeakById(leak.getId());
		leakForSave.setAuditUser(SessionUtil.loginUser());
		leakForSave.setAuditTime(DateUtil.currentTime());
		leakForSave.setAuditResult(leak.getAuditResult());
		leakForSave.setLeakStatus(LeakStatus.已审核.value());
		leakForSave.setAuditOpinion(leak.getAuditOpinion());
		leakDao.update(leakForSave);
		submitAuditLog(leakForSave);//提交审核 日志 
		return Result.SUCCESS;
	}


	/**
	 * 提交审核 日志 
	 * @param leakForSave
	 */
	private void submitAuditLog(Leak leak) {
		String logContent = "提交审核  " +getPartLogContent(leak);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	public String findLastLeakNo() {
		return leakDao.findLastLeakNo();
	}


	/**
	 * 获得指定漏洞的漏洞等级信息
	 * @param leakVo
	 * @return 
	 */
	public List<Map<String,Object>> getRiskLevels(LeakVo leakVo) {
		List<Map<String, Object>> riskLevels = new  ArrayList<Map<String, Object>>();
		
		//高
		Map<String, Object> riskLevel1 = new HashMap<String, Object>();
		riskLevel1.put("riskLevel", RiskLevel.高.value());
		riskLevel1.put("levelName", RiskLevel.高.toString());
		riskLevel1.put("isSelect", RiskLevel.高.value().equals(leakVo.getRiskLevel()));
		riskLevels.add(riskLevel1);
		//中
		Map<String, Object> riskLevel2 = new HashMap<String, Object>();
		riskLevel2.put("riskLevel", RiskLevel.中.value());
		riskLevel2.put("levelName", RiskLevel.中.toString());
		riskLevel2.put("isSelect", RiskLevel.中.value().equals(leakVo.getRiskLevel()));
		riskLevels.add(riskLevel2);
		
		//低
		Map<String, Object> riskLevel3 = new HashMap<String, Object>();
		riskLevel3.put("riskLevel", RiskLevel.低.value());
		riskLevel3.put("levelName", RiskLevel.低.toString());
		riskLevel3.put("isSelect", RiskLevel.低.value().equals(leakVo.getRiskLevel()));
		riskLevels.add(riskLevel3);
		
		return riskLevels;
	}


	/**
	 * 真实  删除漏洞 
	 * @param id
	 * @return
	 */
	public Result realDeleteLeak(Integer id) {
		//判断是否有真实删除权限
		if(!realDeleteRight(id)){
			return Result.error("没有 删除漏洞 权限 ");
		}

		Leak leak = leakDao.findLeakById(id);
		Integer leakId = leak.getId();
		String leakName = leak.getLeakName();
		leakDao.delete(leak);
		realDeleteLeakLog(leakId,leakName);//真实  删除漏洞   日志
		return Result.SUCCESS;
	}

	/**
	 * 判断是否有真实删除权限
	 * @param leakId
	 * @return
	 */
	private boolean realDeleteRight(Integer leakId) {
		Leak po = leakDao.findLeakById(leakId);
		//是自己的漏洞   漏洞审核前           
		if(isSubmitUser(po)&&isBeforAudit(po)){
			return true;
		}
		return false;
	}

	/**
	 * 真实  删除漏洞   日志
	 * @param leakId
	 * @param leakName
	 */
	private void realDeleteLeakLog(Integer leakId, String leakName) {
		String logContent = "删除漏洞   "
				+ " 漏洞id:"
				+leakId
				+ " 漏洞名称:"
				+leakName
				;
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}


	
	
	/**
	 * 是否可修改
	 * 普通用户在漏洞审核前可以修改自己的漏洞，漏洞审核后只有漏洞审核员能够修改。
	 * @param leakId 
	 * @return
	 */
	public boolean getCanUpdate(Integer leakId) {
		Leak po = leakDao.findLeakById(leakId);
		
		//是自己的漏洞   漏洞审核前           
		if(isSubmitUser(po)&&isBeforAudit(po)){
			return true;
		}
		//是漏洞审核员  审核后  已审核(3)
		if(isLeakAuditor()&&isAudited(po)){
			return true;
		}
		return false;
	}
	/**
	 * 是自己的漏洞  
	 * @param po
	 * @return
	 */
	private boolean isSubmitUser(Leak po) {
		if(getLoginUserId() == po.getSubmitUser().getId()){
			return true;
		}
		return false;
	}
	
	/**
	 * 获得登陆用户的id
	 * @return
	 */
	public Integer getLoginUserId() {
		return SessionUtil.loginUser().getId();
	}

	/**
	 *   漏洞审核前            未发布(1),未审核(2),
	 * @param po
	 * @return
	 */
	private boolean isBeforAudit(Leak po) {
		Integer leakStatus = po.getLeakStatus();
		if(LeakStatus.未发布.value().equals(leakStatus)||
				LeakStatus.未审核.value().equals(leakStatus)){
			return true;
		}
		return false;
	}

	/**
	 * 角色是否为漏洞审核员
	 * @return
	 */
	private boolean isLeakAuditor() {
		boolean flag = false;
		Set<SysRole> sysRoles = SessionUtil.loginUser().getSysRoles();
		for (SysRole sysRole : sysRoles) {
			if(SysRoleType.漏洞审计员.value() == sysRole.getId()){
				flag = true;
				break;
			}
		}
		return flag;
	}
	/**
	 * 审核后  已审核(3)
	 * @param po
	 * @return
	 */
	private boolean isAudited(Leak po) {
		if(LeakStatus.已审核.value().equals(po.getLeakStatus())){
			return true;
		}
		return false;
	}
}