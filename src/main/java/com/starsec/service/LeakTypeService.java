package com.starsec.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.starsec.dao.LeakDao;
import com.starsec.dao.LeakTypeDao;
import com.starsec.dao.SysLogDao;
import com.starsec.model.DataTablePage;
import com.starsec.model.Result;
import com.starsec.po.LeakType;
import com.starsec.po.Tool;
import com.starsec.util.SessionUtil;

/**
 * 漏洞类型
 * @author cheng cheng
 *
 */
@Service
public class LeakTypeService{
	
	//用户组
	@Autowired
	private LeakTypeDao leakTypeDao;
	
	
	
	//漏洞dao
	@Autowired
	private LeakDao leakDao;
	
	//日志
	@Autowired
	private SysLogDao sysLogDao;
	//日志模块
	private static final String logTarget = "漏洞类型";

	
	
	
	public List<LeakType> findAll() {
		return leakTypeDao.findAll();
	}
	
	
	/**
	 * 添加修改漏洞类型
	 * @param leakType
	 * @return
	 */
	public Result saveOrUpdateLeakType(LeakType leakType) {
		if(null==leakType.getId()){
			//添加漏洞类型
			return saveLeakType(leakType);
		}else{
			//更新漏洞类型
			return updateLeakType(leakType);
		}
	}

	/**
	 * 更新漏洞类型
	 * @param leakType
	 * @return
	 */
	private Result updateLeakType(LeakType leakType) {
		
		//如果 不是原来的漏洞类型名
		if(!isQuondamName(leakType)){
			//有相同的漏洞名,返回错误
			if(isHaveSameLeakType(leakType)){
				return Result.error("有漏洞类型名称");
			}
		}
		LeakType leakTypeForUpdate = getLeakTypeForUpdate(leakType);
		leakTypeDao.update(leakTypeForUpdate);
		updateLeakTypeLog(leakTypeForUpdate);//更新漏洞类型
		return Result.SUCCESS;
	}

	/**
	 * 更新漏洞类型
	 * @param leakTypeForUpdate
	 */
	private void updateLeakTypeLog(LeakType leakTypeForUpdate) {
		String logContent = "修改漏洞类型  "+getPartLogContent(leakTypeForUpdate);
		saveLog(logContent);
	}


	/**
	 * 是否是原来的漏洞类型名
	 * @param leakType
	 * @return
	 */
	private boolean isQuondamName(LeakType leakType) {
		//用id查询漏洞类型
		LeakType leakTypeFinded = leakTypeDao.get(leakType.getId());
		if(leakTypeFinded.getLeakName().
				equals(leakType.getLeakName())){
			return true;
		}
		return false;
	}


	/**
	 * 添加 漏洞类型
	 * @param leakType
	 * @return
	 */
	private Result saveLeakType(LeakType leakType) {
		//判断是否有相同漏洞类型
		if(isHaveSameLeakType(leakType)){
			return Result.error("有相同的漏洞类型");
		}
		Integer id = (Integer) leakTypeDao.save(leakType);
		saveLeakTypeLog(id);
		return Result.SUCCESS;
	}

	/**
	 * 添加 漏洞类型   日志
	 * @param id 
	 * @return
	 */
	private void saveLeakTypeLog(Integer id) {
		LeakType LeakType = leakTypeDao.get(id);
		String logContent = "添加漏洞类型  "+getPartLogContent(LeakType);
		saveLog(logContent);
	}
	
	

	/**
	 * 判断是否有相同漏洞类型
	 * @param leakType
	 * @return
	 */
	private boolean isHaveSameLeakType(LeakType leakType) {
		Long countLeakType = leakTypeDao.findCountByName(leakType.getLeakName());
		if(countLeakType>0){
			return true;
		}else{
			return false;
		}
	}


	/**
	 * 得到用于更新的漏洞类型
	 * @param leakType
	 * @return
	 */
	private LeakType getLeakTypeForUpdate(LeakType leakType) {
		//查出要更新的对象 
		LeakType leakTypeForUpdate
			= leakTypeDao.get(leakType.getId());
		leakTypeForUpdate.setLeakName(leakType.getLeakName());
		leakTypeForUpdate.setParentId(leakType.getParentId());
		return leakTypeForUpdate;
	}



	/**
	 * string转成数组
	 * @param str
	 * @return
	 */
	public List<Integer> parseStringToIntegerList(String str){
		str=str.replace("[",""); 
		str=str.replace("]",""); 
		String[] ss=str.split(",");
		List<Integer> integerList = new ArrayList<Integer>();
		for (int i = 0; i < ss.length; i++) {
			Integer integer = Integer.parseInt(ss[i]);
			
			integerList.add(integer);
		}
		return integerList;
		
	}


	/**
	 * 删除漏洞类型
	 * @param leakType
	 * @return
	 */
	public Result deleteLeakType(Integer leakTypeId) {
		//检查漏洞类型下是否有子漏洞类型
		Boolean isHaveChildLeakType = checkChildLeakType(leakTypeId);
		//有子漏洞类型返回删除不成功 
		if(isHaveChildLeakType){
			return Result.error("请先删除子漏洞类型");
		}
		//检查漏洞类型下是否有漏洞
		Boolean isHaveLeak = checkLeakInLeakType(leakTypeId);
		//有漏洞返回删除不成功 
		if(isHaveLeak){
			return Result.error("请先删除该漏洞类型下的漏洞信息");
		}
		
		//检查漏洞类型下是否有工具
		Boolean isHaveTool = checkToolInLeakType(leakTypeId);
		//有工具返回删除不成功 
		if(isHaveTool){
			return Result.error("请先删除该漏洞类型对应工具");
		}
		//根据id查到漏洞类型
		LeakType leakTypeForDelete = leakTypeDao.get(leakTypeId);
		Integer  LeakTypeId = leakTypeForDelete.getId();
		String leakTypeName = leakTypeForDelete.getLeakName();
		//开始删除漏洞类型
		boolean isSuccess =  leakTypeDao.deleteLeakType(leakTypeForDelete);
		if(!isSuccess){
			return Result.error("删除不成功");
		}
		deleteLeakTypeLog(LeakTypeId,leakTypeName);//删除漏洞类型 日志
		return Result.SUCCESS;
	}
	

	/**
	 * 删除漏洞类型 日志
	 * @param leakTypeId
	 * @param leakTypeName
	 */
	private void deleteLeakTypeLog(Integer leakTypeId, String leakTypeName) {
		StringBuffer logContent = new StringBuffer();
		logContent.append("删除漏洞类型  ");
		logContent.append(" id:");
		logContent.append(leakTypeId);
		logContent.append("   漏洞类型名:");
		logContent.append(leakTypeName);
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent.toString());
	}


	/**
	 * 检查漏洞类型下是否有工具
	 * @param id
	 * @return
	 */
	private Boolean checkToolInLeakType(Integer id) {
		Boolean isHaveToolInLeakType = false;
		LeakType leakType = leakTypeDao.get(id);
		Set<Tool> tools = leakType.getTools();
		Long count = (long) tools.size();
		if(count>0){
			isHaveToolInLeakType = true;
		}else{
			isHaveToolInLeakType = false;
		}
		return isHaveToolInLeakType;
	}


	/**
	 * 检查漏洞类型下是否有漏洞
	 * @param id
	 * @return
	 */
	private Boolean checkLeakInLeakType(Integer id) {
		Boolean isHaveLeakInLeakType = false;
		LeakType leakType = leakTypeDao.get(id);
		Long count = leakDao.findCountLeakInLeakType(leakType);
		if(count>0){
			isHaveLeakInLeakType = true;
		}else{
			isHaveLeakInLeakType = false;
		}
		return isHaveLeakInLeakType;
	}


	/**
	 * 检查漏洞类型下是否有子漏洞类型
	 * @param id
	 * @return
	 */
	private Boolean checkChildLeakType(Integer id) {
		Boolean isHaveChildLeakType = false;
		Long count = leakTypeDao.findCountChild(id);
		if(count>0){
			isHaveChildLeakType = true;
		}else{
			isHaveChildLeakType = false;
		}
		return isHaveChildLeakType;
	}




	/**
	 * 批量删除漏洞类型
	 * @param idListString
	 * @return
	 */
	public Result deleteLeakTypeList(String idListString) {
		List<LeakType> leakTypeList = new ArrayList<LeakType>();
		  
		List<Integer> idList = parseStringToIntegerList(idListString);
		for (Integer id : idList) {
			//检查漏洞类型下是否有子漏洞类型
			Boolean isHaveChildLeakType = checkChildLeakType(id);
			//有子漏洞类型返回删除不成功 
			if(isHaveChildLeakType){
				return Result.error("请先删除子漏洞类型");
			}
			//检查漏洞类型下是否有漏洞
			Boolean isHaveLeak = checkLeakInLeakType(id);
			//有漏洞
			if(isHaveLeak){
				return Result.error("请先删除该漏洞类型下的漏洞信息");
			}
			
			//检查漏洞类型下是否有工具
			Boolean isHaveTool = checkToolInLeakType(id);
			//有工具
			if(isHaveTool){
				return Result.error("请先删除该漏洞类型对应工具");
			}
			//根据id查到漏洞类型
			LeakType leakTypeForDelete = leakTypeDao.get(id);
			//添加到list
			leakTypeList.add(leakTypeForDelete);
			deleteLeakTypeLog(leakTypeForDelete.getId(),leakTypeForDelete.getLeakName());//删除漏洞类型日志
		
		}
		//开始批量删除漏洞类型
		boolean  isSuccess=  leakTypeDao.deleteLeakTypeList(leakTypeList);
		if(!isSuccess){
			return Result.error("删除不成功");
		}
		return Result.SUCCESS;
		
	}

	/**
	 * 分页查询漏洞类型
	 * @param pageParameBean
	 * @return
	 */
	public DataTablePage findPageLeakTypes(DataTablePage page) {
		//设置页面编号
		page.resetPageNo();
		return leakTypeDao.findPageLeakType(page);
	}


	
	/**
	 *  漏洞类型日志的一部分
	 * @param leak
	 * @return
	 */
	private String getPartLogContent( LeakType leakType) {
		StringBuffer partLogContent = new StringBuffer();
		partLogContent.append(" id:");
		partLogContent.append(leakType.getId());
		partLogContent.append("   漏洞类型名:");
		partLogContent.append(leakType.getLeakName());
		return partLogContent.toString();
	}
	/**
	 * 用日志内容保存日志
	 * @param logContent
	 */
	private void saveLog(String logContent) {
		sysLogDao.createSysLog(SessionUtil.loginUserAccount()
				, logTarget
				, logContent);
	}
	
}